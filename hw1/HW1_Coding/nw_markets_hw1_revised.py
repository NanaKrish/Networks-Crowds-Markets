# -*- coding: utf-8 -*-
"""NW&Markets_HW1_Revised.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m2aORCZA6YUnzMnQxtG5eoRNwER1mwNh
"""

from collections import deque
import random
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""# New Section

#8A
In graph.py, implement (and turn in) a function create graph(n,p)  that produces an undirected graph with n nodes where each pair of nodes is connected by an edge with probability p.
"""

def create_graph(n, p):
  graph = dict()
  for i in range(n):
    for j in range(i+1, n):
      if (i not in graph.keys()):
        graph[i] = []
      if (j not in graph.keys()):
        graph[j] = []
      if (random.random() <= p):
        graph[i] = graph[i] + [j]
        graph[j] = graph[j] + [i]
  return graph

"""#8B
Implement a general shortest-path algorithm for  graphs, as described in lecture, that works on your graph. In graph.py, include a function $shortestpath(G,i,j)$ that outputs the length of the shortest path from node $i$ to $j$ in your graph $G$. Make sure to handle the case where the graph is disconnected (i.e.  no shortest path exists) by outputting “infinity”.
"""

#Code implementation courtesy of --> https://codereview.stackexchange.com/questions/193410/breadth-first-search-implementation-in-python-3-to-find-path-between-two-given-n

def shortest_path(G, i, j):
  if i == j:
    return [i]
  visited = {i}
  queue = deque([(i, [])])
  
  while queue:
    current, path = queue.popleft()
    visited.add(current)
    for neighbor in G[current]:
      if neighbor == j:
        return path + [current, neighbor]
      if neighbor in visited:
        continue
      queue.append((neighbor, path + [current]))
      visited.add(neighbor)
  return "infinity"  # no path found. not strictly needed

"""#8C
Construct a graph for $n= 1000$ and $p= 0.1$.  Estimate the average shortest path between a  random  pair  of  two  (connected)  nodes  in  the  graph.   For  accuracy,  repeat  for 1000 random pairs of nodes in your graph.  Output an execution trace in **avgshortestpath.txt** containing all path lengths written as $(i,j,length)$.
"""

avg_path_doc = open("/content/avg_shortest_path.txt", "w")
graph_1000 = create_graph(1000, 0.1)
lengths = []
for i in range(1000):
  rand_node_one = random.randint(0, 999)
  rand_node_two = random.randint(0, 999)
  z = shortest_path(graph_1000, rand_node_one, rand_node_two)
  lengths.append(len(z)-1)
  avg_path_doc.write("(%d, %d, %d)\n" %(rand_node_one, rand_node_two, len(z)-1))
  
avg_length = sum(lengths)/1000
print(avg_length)

"""#8D
For $n= 1000$, run the shortest-path algorithm on data sets for many values of $p$ (for instance, 0.01 to 0.04 using .01 increments, and then 0.05 to 0.5 using .05 increments). Turn in your numerical data as **varyingp.txt**, and plot the average shortest path as a function of $p$ and submit as an image file **varyingp**.(image extension) or include in **yourmain.pdf** file.

*Note: For p=  0.01  there  is  actually  a  small  but  reasonable  chance  (around  4%)  toproduce a disconnected graph.  If this occurs, resample and produce a connected graphfor the purposes of gathering data.*
"""

avg_len = []
x_val = []

for i in np.arange(0.01, 0.05, 0.01):
  x_val.append(i)
  graph_varying_p = create_graph(1000, i)
  lengths = []
  for j in range(1000):
    rand_node_one = random.randint(0, 999)
    rand_node_two = random.randint(0, 999)
    z = shortest_path(graph_varying_p, rand_node_one, rand_node_two)
    lengths.append(len(z)-1)    
  avg_len.append(sum(lengths)/1000)
  
plt.plot(x_val, avg_len, '-o')
plt.xlabel("Probability of Creating Edges")
plt.ylabel("Average Shortest Length")

for i in np.arange(0.05, 1, 0.05):
  x_val.append(i)
  graph_varying_p = create_graph(1000, i)
  lengths = []
  for i in range(100):
    rand_node_one = random.randint(0, 999)
    rand_node_two = random.randint(0, 999)
    z = shortest_path(graph_varying_p, rand_node_one, rand_node_two)
    lengths.append(len(z)-1)
  avg_len.append(sum(lengths)/100)
  
plt.plot(x_val,avg_len, '-o')
plt.xlabel("Probability of Creating Edges")
plt.ylabel("Average Shortest Length")

#writing varying_p.csv for submission

varying_p_data = list(zip(x_val, avg_len))
varying_p_df = pd.DataFrame(varying_p_data, columns = ['Probability', ' Average Shortest Length'])  
     
varying_p_df.index.name = "varying_p"
varying_p_df.to_csv("/content/varying_p.csv")

"""#8E
Intuitively  explain  the  behavior  of  the  data  you  found;  specifically,  as $p$ increases  (in particular, look at the larger values, e.g. 0.3 and above), what function does the average shortest path length seem to asymptotically approach and why?

The average shortest path length of the Facebook data appears to be greater than expected if it were a random graph with the same number of nodes and value of $p$. For a random graph of ($n$ = 4039, $p$ = 0.005), we had an average distance of $\thicksim 3.04$.

#9(a) - (c)
"""

fb_df = pd.read_csv("https://raw.githubusercontent.com/hui-liu/Bioinformatics-Scripts/master/data/facebook_combined.csv", sep = ',', header='infer')

# getting data from csv into adjacency list

from collections import defaultdict

fb_nodes = set(fb_df.iloc[:,0])
fb_graph = defaultdict(set)

for i in range(len(fb_df)):
  fb_graph[fb_df.iloc[i,0]].add(fb_df.iloc[i,1])
  fb_graph[fb_df.iloc[i,1]].add(fb_df.iloc[i,0])

fb_df.iloc[:, 0]

fb_path_doc = open("/content/fb_shortest_path.txt", "w")

lengths = []
for i in range(1000):
  rand_node_one = random.randint(0, max(fb_nodes))
  rand_node_two = random.randint(0, max(fb_nodes))
  z = shortest_path(fb_graph, rand_node_one, rand_node_two)
  lengths.append(len(z)-1)
  fb_path_doc.write("(%d, %d, %d)\n" %(rand_node_one, rand_node_two, len(z)-1))
  
avg_len = (sum(lengths)/1000)
print(avg_len)

n = 4039
fb_edges = 88234
total_edges = n*(n-1)/2

prob = fb_edges/total_edges
prob

max(fb_nodes)

graph_fb = create_graph(4039, 0.0108)
lengths = []
for i in range(1000):
  rand_node_one = random.randint(0, 4038)
  rand_node_two = random.randint(0, 4038)
  z = shortest_path(graph_fb, rand_node_one, rand_node_two)
  lengths.append(len(z)-1)
  
avg_length = sum(lengths)/1000
print(avg_length)